;;; lib/net/codec/dns.lisp --- DNS Record utils

;; from: https://github.com/Shinmera/dns-client

;;; Code:
(in-package :net/codec/dns)

(defparameter *record-type-table*
  '((:A 1)
    (:AAAA 28)
    (:AFSDB 18)
    (:APL 42)
    (:CAA 257)
    (:CDNSKEY 60)
    (:CDS 59)
    (:CERT 37)
    (:CNAME 5)
    (:CSYNC 62)
    (:DHCID 49)
    (:DLV 32769)
    (:DNAME 39)
    (:DNSKEY 48)
    (:DS 43)
    (:HINFO 13)
    (:HIP 55)
    (:IPSECKEY 45)
    (:KEY 25)
    (:KX 36)
    (:LOC 29)
    (:MX 15)
    (:NAPTR 35)
    (:NS 2)
    (:NSEC 47)
    (:NSEC3 50)
    (:NSEC3PARAM 51)
    (:OPENPGPKEY 61)
    (:PTR 12)
    (:RRSIG 46)
    (:RP 17)
    (:SIG 24)
    (:SMIMEA 53)
    (:SOA 6)
    (:SRV 33)
    (:SSHFP 44)
    (:TA 32768)
    (:TKEY 249)
    (:TLSA 52)
    (:TSIG 250)
    (:TXT 16)
    (:URI 256)
    (:ZONEMD 63)
    ;; Pseudo records
    (T 255)
    (* 255)
    (:* 255)
    (:AXFR 252)
    (:IXFR 251)
    (:OPT 41)
    ;; Obsolete
    (:MD 3)
    (:MF 4)
    (:MAILA 254)
    (:MB 7)
    (:MG 8)
    (:MR 9)
    (:MINFO 14)
    (:MAILB 253)
    (:WKS 11)
    (:NB 32)
    (:NBSTAT 33)
    (:NULL 10)
    (:A6 38)
    (:NXT 30)
    (:KEY 25)
    (:SIG 24)
    (:HINFO 13)
    (:RP 17)
    (:X25 19)
    (:ISDN 20)
    (:RT 21)
    (:NSAP 22)
    (:NSAP-PTR 23)
    (:PX 26)
    (:EID 31)
    (:NIMLOC 32)
    (:ATMA 34)
    (:APL 42)
    (:SINK 40)
    (:GPOS 27)
    (:UINFO 100)
    (:UID 101)
    (:GID 102)
    (:UNSPEC 103)
    (:SPF 99)
    (:NINFO 56)
    (:RKEY 57)
    (:TALINK 58)
    (:NID 104)
    (:L32 105)
    (:L64 106)
    (:LP 107)
    (:EUI48 108)
    (:EUI64 109)
    (:DOA 259)))

(defun record-type-id (record-type &optional (error T))
  (or (second (find record-type *record-type-table* :key #'first :test #'string-equal))
      (when error "No such record type ~s" record-type)))

(defun id-record-type (id)
  (or (first (find id *record-type-table* :key #'second :test #'=))
      id))

(defun encode-host (name octets offset)
  (let ((start 0)
        (name (encode-domain name)))
    (flet ((finish (end)
             (setf (aref octets (+ offset start)) (- end start))
             (loop for i from (1+ start) to end
                   do (setf (aref octets (+ offset i)) (char-code (char-downcase (char name (1- i))))))
             (setf start (1+ end))))
      (loop for i from 0 below (length name)
            do (when (char= #\. (char name i))
                 (finish i))
            finally (finish (length name)))
      (setf (aref octets (+ offset start)) 0)
      (+ offset start 1))))

(defun decode-host* (string)
  (loop with i = 0
        while (< i (length string))
        do (let ((jump (char-code (char string i))))
             (setf (char string i) #\.)
             (incf i (1+ jump))))
  (decode-domain
   (if (string/= "" string)
       (subseq string 1)
       string)))

(defun decode-host (octets offset start)
  (loop with i = offset
        with pos = offset
        with jumped = NIL
        with stream = (make-string-output-stream)
        until (= 0 (aref octets i))
        ;; Handle label compression jump
        do (cond ((<= 192 (aref octets i))
                  (setf i (+ start
                             (- (+ (* 256 (aref octets i)) (aref octets (1+ i)))
                                #b1100000000000001)))
                  (setf jumped T)
                  (incf pos 1))
                 (T
                  (write-char (code-char (aref octets i)) stream)))
           (incf i)
           (unless jumped
             (incf pos))
        finally (return (values (decode-host* (get-output-stream-string stream)) (1+ pos)))))

(defun decode-header (octets offset)
  (with-decoding (octets offset pos)
    (values (list :id (int16)
                  :recursion-desired (int1)
                  :truncated-message (int1)
                  :authorative-answer (int1)
                  :operation (int4)
                  :reply-p (int1)
                  :response-code (int4)
                  :checking-disabled (int1)
                  :authenticated-data (int1)
                  :z-reserved (int1)
                  :recursion-available (int1)
                  :question-count (int16)
                  :answer-count (int16)
                  :authority-count (int16)
                  :additional-count (int16))
            pos)))

(defun encode-header (octets offset &key id recursion-desired truncated-message authorative-answer operation reply-p response-code checking-disabled authenticated-data z-reserved recursion-available question-count answer-count authority-count additional-count)
  (maybe-set (octets offset)
    (int16 id)
    (int1 recursion-desired)
    (int1 truncated-message)
    (int1 authorative-answer)
    (int4 operation)
    (int1 reply-p)
    (int4 response-code)
    (int1 checking-disabled)
    (int1 authenticated-data)
    (int1 z-reserved)
    (int1 recursion-available)
    (int16 question-count)
    (int16 answer-count)
    (int16 authority-count)
    (int16 additional-count)))

(defun encode-query (octets offset hostname &key type class)
  (let ((type (etypecase type
                ((or string symbol) (record-type-id type))
                ((unsigned-byte 16) type))))
    (setf offset (encode-host hostname octets offset))
    (maybe-set (octets offset)
      (int16 type)
      (int16 class))))

(defun decode-query (octets offset)
  (with-decoding (octets offset pos)
    (values (list :type (id-record-type (int16))
                  :class (int16))
            pos)))

(defun decode-data (octets offset)
  (with-decoding (octets offset pos)
    (values (list :type (id-record-type (int16))
                  :class (int16)
                  :ttl (int32)
                  :length (int16))
            pos)))

(defgeneric decode-record-payload (type octets start end))

(defmethod decode-record-payload (type octets start end)
  (subseq octets start end))

(defmethod decode-record-payload ((type (eql :A)) octets start end)
  (format NIL "~d.~d.~d.~d"
          (aref octets (+ 0 start))
          (aref octets (+ 1 start))
          (aref octets (+ 2 start))
          (aref octets (+ 3 start))))

(defmethod decode-record-payload ((type (eql :AAAA)) octets start end)
  (usocket:vector-to-ipv6-host octets))

(defmethod decode-record-payload ((type (eql :TXT)) octets start end)
  (decode-host octets start 0))

(defmethod decode-record-payload ((type (eql :URI)) octets start end)
  (decode-host octets start 0))

(defmethod decode-record-payload ((type (eql :CNAME)) octets start end)
  (decode-host octets start 0))

(defmethod decode-record-payload ((type (eql :PTR)) octets start end)
  (decode-host octets start 0))

;; TODO: decode more.

(defmethod decode-record-payload ((type (eql :MX)) octets start end)
  (with-decoding (octets start pos)
    (list :priority (int16)
          :name (decode-host octets pos 0))))

(defmethod decode-record-payload ((type (eql :SOA)) octets start end)
  (multiple-value-bind (mname pos) (decode-host octets start 0)
    (multiple-value-bind (rname pos) (decode-host octets pos 0)
      (with-decoding (octets pos)
        (list :mname mname
              :rname rname
              :serial (int32)
              :refresh (int32)
              :retry (int32)
              :expire (int32)
              :minimum (int32))))))

(defun decode-record (octets offset)
  (multiple-value-bind (data pos) (decode-data octets offset)
    (setf (getf data :data) (decode-record-payload (getf data :type) octets pos (+ pos (getf data :length))))
    (values data (+ pos (getf data :length)))))

(defun decode-response (server octets offset limit)
  ;; FIXME: Implement buffer limiting.
  (multiple-value-bind (header pos) (decode-header octets offset)
    (when (< 0 (getf header :response-code))
      (error 'dns-server-failure :dns-server server :response-code (getf header :response-code)))
    (let ((record-offset pos))
      (flet ((decode (fun)
               (multiple-value-bind (name pos) (decode-host octets record-offset offset)
                 (multiple-value-bind (query pos) (funcall fun octets pos)
                   (setf record-offset pos)
                   (setf (getf query :name) name)
                   query))))
        (list* :questions
               (loop repeat (getf header :question-count)
                     collect (decode #'decode-query))
               :answers
               (loop repeat (getf header :answer-count)
                     collect (decode #'decode-record))
               :authorities
               (loop repeat (getf header :authority-count)
                     collect (decode #'decode-record))
               :additional
               (loop repeat (getf header :additional-count)
                     collect (decode #'decode-record))
               header)))))
